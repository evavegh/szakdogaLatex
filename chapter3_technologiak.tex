%----------------------------------------------------------------------------
\chapter{Választott technológiák}
%----------------------------------------------------------------------------

A következõkben felsorolom a projekt elkészítése során használt fõbb technológiákat. A kisebb, kevésbé fontos technikákat, könyvtárakat itt nem részletezem, ezek használatára csak a következõ fejezetekben térek ki (\ref{tervezes} fejezet és Megvalósítás fejezetek).

%----------------------------------------------------------------------------
\section{Maven} \label{maven}
%----------------------------------------------------------------------------
A Maven egy parancssori build automatizáló eszköz, amely képes a függõségek (.jar-ok) feloldására és automatikus letöltésére, akár tranzitív függõségeknél is. Leírja, hogyan épül fel a projekt, illetve meghatározza a projekt más moduloktól vagy könyvtáraktól való függõségeit. Ezeket az információkat a pom.xml (Project Object Model) nevû fájlban tárolja, ami magában foglalja többek között a projekt nevét, tulajdonosát és a függõségek listáját.


A tesztelést integrálja a buildelési folyamatba, Unit és integrációs tesztek is támogatottak. Erõsen testre szabható, de csak akkor van rá szükség, ha eltérünk a default-októl (pl. könyvtárstruktúra). Ez annak köszönhetõ, hogy a Maven fontos alapelve a Convention over Configuration (konvenciók a beállítások elõtt), amivel kevesebb konfigurációs beállítást kell elvégeznünk, arra ösztönöz, hogy az alapértelmezett mûködést használjuk.

%----------------------------------------------------------------------------
\section{Spring}
%----------------------------------------------------------------------------
A Spring egy nyílt forráskódú, Java alkalmazás keretrendszer, amelynek elsõdleges célja, hogy a vállalati környezetbe szánt Java alkalmazások fejlesztését egyszerûbbé tegye. Az IoC (Inversion of Control) tervezési minta megvalósításával segít az alkalmazás objektumainak konfigurálásban, ,,összedrótozásában''. Az objektumgráfok elõállítását az injektor végzi el. Az általunk végzett konfiguráció megoldható annotációk használatával. A Spring kezeli az infrastruktúrát, így a fejlesztés során az alkalmazás fejlesztésére koncentrálhatunk. Használatával biztosíthatjuk az elemek közötti laza csatolást, az alkalmazás különbözõ rétegeinek szétválasztását, többek között a megjelenítés leválasztását a mûködési logikáról.

Moduláris felépítésû, így csak azokat a részeit kell használnunk, amire szükségünk van.

Támogatja a tranzakciókezelést, a távoli hozzáférést, teljes értékû MVC kertrendszert biztosít. Lehetõvé teszi, hogy POJO-k (plain old Java object) segítségével építsük fel az alkalmazásunkat.

%----------------------------------------------------------------------------
\section{Spring Boot}
%----------------------------------------------------------------------------

Az alkalmazás megvalósításához a Spring Boot keretrendszert választottam. A Spring keretrendszer szintén támogatja a CoC-t (ld. \ref{maven} szakasz), tehát nem szükséges külön konfigurációt vagy programkódot írnunk, ha az elterjedt konvenciókat követjük. A szoftverünk csak azon részeihez szükséges konfigurációt vagy extra kódsorokat létrehoznunk, amelyek eltérnek a praktikusan megválasztott alapértelmezett
mûködéstõl.

A Spring Boot ezeket az alapelveket emeli még magasabb szintre. Tovább egyszerûsíti az alkalmazás konfigurálását és a komponensek közti integrációt. A megírt kód alapján feltérképezi a programozó szándékait, és automatikusan konfigurálja a kapcsolódó háttérszolgáltatásokat. Az így hozzáadott funkcionalitás programozói erõfeszítés nélkül jön létre, így jelentõsen leegyszerûsödik a fejlesztés folyamata.

%----------------------------------------------------------------------------
\section{Spring MVC}
%----------------------------------------------------------------------------
A Spring MVC a Spring keretrendszer része, ami egy kérés (request) alapú keretrendszer és szorosan kapcsolódik a Servlet API-hoz.

A Spring MVC használata során a kérések egy DispatcherServlet nevû szervlethez érkeznek be, aminek a felelõssége, hogy a kéréseket a megfelelõ interfészekhez delegálja, úgy mint:
\begin{description}[itemsep=0mm]
	\item[HandlerMapping:] Kiválasztja a megfelelõ objektumokat a kérések lekezelésére valamilyen paraméter, vagy feltétel alapján.
	\item[Controller:] A modell és a felület közötti réteg az MVC struktúrában, feladata a bejövõ kérések kezelése és a megfelelõ válaszok visszaküldése.
	\item[ViewResolver:] Visszaadja a felület sablonját a logikai neve alapján, amit lerenderelve vissza lehet küldeni a kliensnek válaszként.
	\item[View:] A kliensnek küldött felület a modellbõl érkezett adatokkal kitöltve.
\end{description}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figures/spring_mvc.png}
	\caption{Kérés kiszolgálása a Spring MVC-ben}
	\label{fig:spring_mvc}
\end{figure}

%----------------------------------------------------------------------------
\section{Spring Data}
%----------------------------------------------------------------------------
A Spring Data egy külön modul az adatelérés támogatására, amivel az adatelérési kód nagy része megspórolható, hiszen egyszerûen tudunk saját entitásra specifikus repository-t írni, ami a JpaRepository<T, ID extends Serializable> interfész leszármazottja.

Az interfészbe felvett findBy\dots\ metódusok nevei alapján egyéb lekérdezések generálhatók.

%----------------------------------------------------------------------------
\section{JPA}
%----------------------------------------------------------------------------
A JPA egy szabványos ORM API specifikáció, aminek az alkalmazás relációs adatainak kezelése a fõ feladata.

Az ORM keretrendszerek legfõbb hátránya, hogy sokszor nehézkes az általánostól eltérõ, összetett funkciókat megvalósítani, mert túl magas szinten mûködnek. Ezt a JPA azzal oldja meg, hogy csak interfészeket specifikál, ezzel téve lehetõvé a több lehetséges implementációt. A JPA legnépszerûbb implementációja a Hibernate, én is ezt használtam a projekt elkészítése során.

Egy JPA entitás egy olyan osztály, melynek példányait a JPA relációs adatbázisban perzisztensen tárolja. Az O -- R leképezés annotációkkal konfigurálható.

Az entitásokat az EntityManager interfészen keresztül tudjuk kezelni, ezen keresztül érhetjük el a perzisztenciakontextust, ami a memóriabeli entitások és az adatbázis közti kapcsolatot jelenti.

%----------------------------------------------------------------------------
\section{REST}
%----------------------------------------------------------------------------
A szabványos HTTP kérés -- válaszokra építve, az elérendõ erõforrásokat külön-külön egyedi URI-hoz rendelve építjük fel szolgáltatásunkat. Az URI-k egységes interfészt biztosítanak a kliens számára. Minden kérésre azonos formátumban reagál a szerver, ez általában JSON, HTML vagy XML.

REST használatával biztosíthatjuk a kliens és a szerver egymástól való elkülönítését, hiszen a köztük lévõ kommunikáció az interfészeken zajlik. A kommunikáció állapotmentes, tehát nem tárolhatunk semmilyen információt a klienstõl a kérések között, a kéréseknek minden szükséges adatot tartalmazniuk kell.

%----------------------------------------------------------------------------
\section{Thymeleaf}
%----------------------------------------------------------------------------
A Thymeleaf egy olyan Java alapú template engine, ami XML/HTML/HTML5 template fájlok kezelését biztosítja rugalmasan bõvíthetõ dialektusokkal. A th: névtérbe tett attribútumokkal bõvítve egyszerûen designolható, a template fájl szerkesztéséhez nincs szükség szerver futtatására. Ez nagyban meggyorsítja a fejlesztési folyamatot, illetve a template fájlok továbbíthatók a designernek, aki egyszerûen dolgozhat velük segédprogramok használata nélkül.

Thymeleaf fragmentek használatával az egyes elemek, layoutok könnyen újrahasznosíthatóak, ezzel is átláthatóbbá téve a kódunk szerkezetét.

%----------------------------------------------------------------------------
\section{Angular 4}
%----------------------------------------------------------------------------
Az Angular egy olyan frontend keretrendszer, amelynek telepítésével egy olyan JavaScript könyvtárhoz jutunk, amivel szinte bármit meg tudunk valósítani kliens oldalon. Szerver oldaltól függetlenül használható, az alkalmazás futtatása nem igényel telepítést. Moduláris felépítésének köszönhetõen elõdeinél gyorsabb betöltést és könnyû tesztelhetõséget biztosít.

Saját validálási módszereivel egyedi ellenõrzéseket végezhetünk kliens oldalon, így csökkentve a felesleges kérések számát a szerver felé.
Fejlett eseményvezérelt rendszerén keresztül megoldható a többirányú adatkötés: egy adat több helyen történõ megjelenését összehangolja, ezzel is csökkentve a lekérések számát.

Elsõdleges nyelve a TypeScript, ami erõs típusosságával sokkal megbízhatóbb és biztonságosabb kódok írását teszi lehetõvé, hiszen számos hiba már kódolás közben vagy fordítás alatt kiderülhet.

Az Angular 2-ben mutatkozott be az Angular Universal, amely még szerveroldalon elkészíti, elõrendereli a first viewt, és statikus tartalomként küldi el a kliensnek. Ezután kezdi meg a webapp elemeinek letöltését és dinamikus beágyazását az oldalba. Ennek köszönhetõen oldható meg az SPA (Single Page Application) kivitelezése, hiszen az adatok változása esetén csak a tartalmat kell frissíteni, nem az egész oldalt.

%----------------------------------------------------------------------------
\section{AJAX, jQuery, KnockoutJS}
%----------------------------------------------------------------------------
Az egyszerû HTTP kérésekkel szemben az AJAX használata lehetõvé teszi, hogy a böngészõbõl aszinkron módon küldjünk kéréseket a szervernek. A szerver válaszát szintén JavaScript segítségével fogadjuk. Ennek köszönhetõen az oldal elemei egymástól függetlenül módosíthatóak, így például adatfrissítés esetén nem szükséges az egész oldalt újratölteni, csak az egyes elemeket, és a felhasználói élmény folyamatosabb, kellemesebb lesz.

A jQuery segítségével tudjuk a DOM-ot (Document Object Model) manipulálni, eseménykezelõket definiálni az oldalon.

A KnockoutJS ezeket kiegészíti azzal, hogy kétirányú adatkötést valósít meg, a HTML elemeket hozzárendeli a ViewModel objektumokhoz, így az egyik módosítása maga után vonja a másik változását.

Ezt a három felsorolt technológiát a Thymeleaffel együtt használtam, az Angular alapú oldalaknál mindezt az Angular magában foglalja, ezért ott nem kellett vele külön foglalkozni.

%----------------------------------------------------------------------------
\section{Bootstrap}
%----------------------------------------------------------------------------
A Bootstrap egy olyan front-end keretrendszer, aminek segítségével egyszerûen készíthetünk reszponzív weboldalakat. Olyan CSS szabályokat, JavaScript függvényeket és HTML mintákat tartalmaz, amelyek segítségével összetettebb komponensek is könnyen elkészíthetõk a saját ízlésünkre szabva.